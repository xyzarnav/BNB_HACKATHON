{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/TrustChain.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// Use openzeppelin to inherit battle-tested implementations (ERC20, ERC721, etc)\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * A smart contract that allows changing a state variable of the contract and tracking the changes\r\n * It also allows the owner to withdraw the Ether in the contract\r\n * @author BuidlGuidl\r\n */\r\ncontract TrustChain is Ownable, ReentrancyGuard {\r\n    constructor() Ownable(msg.sender) {}\r\n\r\n    // Events\r\n    event BidderCreated(address indexed bidder, uint256 bidderId);\r\n    event ProjectCreated(uint256 indexed projectId, address creator, uint256 budget, ProjectClassfication projectType);\r\n    event BidSubmitted(uint256 indexed bidId, uint256 projectId, address bidder, uint256 amount);\r\n    event BondAwarded(uint256 indexed projectId, address bidder, uint256 amount, uint256 initialPayment);\r\n    event PaymentReleased(uint256 indexed bondId, uint256 amount, ProjectCompletion newCompletion);\r\n    // New transparency events\r\n    event AuditorAssigned(uint256 indexed projectId, address auditor);\r\n    event AuditorApproval(uint256 indexed bondId, ProjectCompletion milestone);\r\n    event MediatorAssigned(uint256 indexed disputeId, address mediator);\r\n    event DisputeResolved(uint256 indexed disputeId, DisputeOutcome outcome);\r\n    event WhistleblowerReport(uint256 indexed projectId, bytes32 reportHash);\r\n    event TransparencyLog(uint256 indexed projectId, string action, address actor);\r\n\r\n    uint256 public version = 4;\r\n    uint256 public projectId = 0;\r\n    uint256 public bidCount = 0;\r\n    uint256 public bondCount = 0;\r\n    uint256 public disputeCount = 0;\r\n\r\n    struct Project {\r\n        address creator;\r\n        uint256 projectId;\r\n        string description;\r\n        string title;\r\n        uint256 timePeriod;\r\n        uint256 deadline;\r\n        uint256 budget;\r\n        bool posted;\r\n        ProjectClassfication projectType;\r\n        address auditor; // Independent auditor to verify milestones\r\n        bool hasAuditor;\r\n    }\r\n\r\n    struct Bid {\r\n        uint256 bidId;\r\n        uint256 projectId;\r\n        address bidder;\r\n        uint amount;\r\n        string proposalIPFHash;\r\n        bool accepted;\r\n    }\r\n\r\n    struct Bidder {\r\n        uint bidderId;\r\n        address bidderAddress;\r\n        uint256 totalBids;\r\n        uint256 reputationScore;\r\n        bool blacklisted; // For bidders caught in corrupt activities\r\n    }\r\n\r\n    struct Bond {\r\n        address obligor;\r\n        uint projectId;\r\n        uint amount;\r\n        ProjectStatus status;\r\n        ProjectCompletion completion;\r\n        mapping(address => bool) approvals; // Multi-signature approvals\r\n        uint256 requiredApprovals;\r\n        uint256 currentApprovals;\r\n        mapping(ProjectCompletion => bool) milestoneApproved; // Track which milestones are approved\r\n    }\r\n\r\n    struct Dispute {\r\n        uint256 disputeId;\r\n        uint256 bondId;\r\n        address creator;\r\n        address mediator;\r\n        string evidence;\r\n        bool resolved;\r\n        DisputeOutcome outcome;\r\n    }\r\n\r\n    enum ProjectStatus {\r\n        Approved,\r\n        Completed,\r\n        Disputed\r\n    }\r\n\r\n    enum ProjectClassfication {\r\n        MaxRate,\r\n        FixRate,\r\n        MinRate\r\n    }\r\n\r\n    enum ProjectCompletion {\r\n        Signed, // 20%\r\n        Quarter, // 40%\r\n        Half, // 60%\r\n        ThreeQuarters, // 80%\r\n        Full // 100%\r\n    }\r\n\r\n    enum DisputeOutcome {\r\n        Pending,\r\n        RuledForCreator,\r\n        RuledForObligor,\r\n        Compromise\r\n    }\r\n\r\n    uint256 public bidderCount;\r\n    mapping(uint256 => Project) public projects;\r\n    mapping(uint256 => Bid) public bids;\r\n    mapping(uint256 => Bidder) public bidders;\r\n    mapping(uint256 => uint256[]) public projectBids;\r\n    mapping(address => uint256) public bidderIds;\r\n    mapping(uint256 => Dispute) public disputes;\r\n\r\n    // Mapping for Bond struct with nested mapping\r\n    mapping(uint256 => address) private bondObligor;\r\n    mapping(uint256 => uint256) private bondProjectId;\r\n    mapping(uint256 => uint256) private bondAmount;\r\n    mapping(uint256 => ProjectStatus) private bondStatus;\r\n    mapping(uint256 => ProjectCompletion) private bondCompletion;\r\n    // New mapping to track milestone approvals\r\n    mapping(uint256 => mapping(ProjectCompletion => bool)) private bondMilestoneApproved;\r\n    mapping(address => mapping(uint256 => bool)) public hasBidded;\r\n    // Auditor system\r\n    mapping(address => bool) public approvedAuditors;\r\n    mapping(uint256 => address[]) public projectAuditors;\r\n    // BidEvaluation\r\n    mapping(uint256 => bool) public evaluatedbids;\r\n    // Bond Winners\r\n    mapping(uint256 => uint256) public bondWinners;\r\n    // Whistleblower system\r\n    mapping(bytes32 => string) private reportDescriptions;\r\n    mapping(bytes32 => bool) private whistleblowerReports;\r\n    mapping(bytes32 => uint256) private whistleblowerRewards;\r\n\r\n    // Transparency log\r\n    struct LogEntry {\r\n        address actor;\r\n        string action;\r\n        uint256 timestamp;\r\n    }\r\n    mapping(uint256 => LogEntry[]) public transparencyLogs;\r\n\r\n    // Create a log entry for important actions\r\n    function _createLog(uint256 _projectId, string memory _action) private {\r\n        transparencyLogs[_projectId].push(LogEntry({ actor: msg.sender, action: _action, timestamp: block.timestamp }));\r\n        emit TransparencyLog(_projectId, _action, msg.sender);\r\n    }\r\n    // Add this state variable to the contract\r\n    address[] public approvedAuditorsList;\r\n    // Register as an approved auditor\r\n    function registerAuditor(address _auditor) public onlyOwner {\r\n        require(!approvedAuditors[_auditor], \"Auditor already registered\");\r\n        approvedAuditors[_auditor] = true;\r\n        approvedAuditorsList.push(_auditor);\r\n    }\r\n\r\n    function removeAuditor(address _auditor) public onlyOwner {\r\n        require(approvedAuditors[_auditor], \"Auditor not registered\");\r\n        approvedAuditors[_auditor] = false;\r\n\r\n        // Remove from the array\r\n        for (uint i = 0; i < approvedAuditorsList.length; i++) {\r\n            if (approvedAuditorsList[i] == _auditor) {\r\n                // Replace with the last element and pop\r\n                approvedAuditorsList[i] = approvedAuditorsList[approvedAuditorsList.length - 1];\r\n                approvedAuditorsList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function createBidder() public {\r\n        require(bidderIds[msg.sender] == 0, \"Bidder already exists\");\r\n        require(!bidders[bidderIds[msg.sender]].blacklisted, \"Address is blacklisted\");\r\n        bidderCount++;\r\n        bidderIds[msg.sender] = bidderCount;\r\n        bidders[bidderCount] = Bidder({\r\n            bidderId: bidderCount,\r\n            bidderAddress: msg.sender,\r\n            totalBids: 0,\r\n            reputationScore: 0,\r\n            blacklisted: false\r\n        });\r\n        emit BidderCreated(msg.sender, bidderCount);\r\n    }\r\n\r\n    function createProject(\r\n        string memory _title,\r\n        string memory _description,\r\n        uint256 _timeperiod,\r\n        uint _budget,\r\n        ProjectClassfication _jobType\r\n    ) public {\r\n        require(bytes(_description).length > 0, \"Description cannot be empty\");\r\n        require(bytes(_title).length > 0, \"Description cannot be empty\");\r\n        require(_timeperiod > 0, \"Time period must be positive\");\r\n        require(_budget > 0, \"Budget must be positive\");\r\n\r\n        projectId++;\r\n        projects[projectId] = Project({\r\n            creator: msg.sender,\r\n            projectId: projectId,\r\n            description: _description,\r\n            budget: _budget,\r\n            title: _title,\r\n            timePeriod: _timeperiod,\r\n            deadline: block.timestamp + _timeperiod,\r\n            posted: true,\r\n            projectType: _jobType,\r\n            auditor: address(0),\r\n            hasAuditor: false\r\n        });\r\n\r\n        emit ProjectCreated(projectId, msg.sender, _budget, _jobType);\r\n\r\n        _createLog(projectId, \"PROJECT_CREATED\");\r\n    }\r\n\r\n    // Assign an auditor to an existing project\r\n    function assignAuditor(uint256 _projectId) public {\r\n        Project storage project = projects[_projectId];\r\n        require(msg.sender == project.creator, \"Only creator can assign auditor\");\r\n        require(approvedAuditorsList.length > 0, \"No approved auditors available\");\r\n        require(!project.hasAuditor, \"Auditor already assigned\");\r\n\r\n        // Generate a pseudorandom number for auditor selection\r\n        uint256 randomIndex = uint256(\r\n            keccak256(abi.encodePacked(block.timestamp, block.prevrandao, msg.sender, _projectId))\r\n        ) % approvedAuditorsList.length;\r\n\r\n        // Assign the randomly selected auditor\r\n        address selectedAuditor = approvedAuditorsList[randomIndex];\r\n        project.auditor = selectedAuditor;\r\n        project.hasAuditor = true;\r\n\r\n        emit AuditorAssigned(_projectId, selectedAuditor);\r\n        _createLog(_projectId, \"AUDITOR_ASSIGNED\");\r\n    }\r\n\r\n    // Whistleblower function to report corruption\r\n    function reportCorruption(uint256 _projectId, string memory _evidence) public {\r\n        bytes32 reportHash = keccak256(abi.encodePacked(_projectId, msg.sender, _evidence));\r\n        whistleblowerReports[reportHash] = true;\r\n        reportDescriptions[reportHash] = _evidence; // Store the evidence\r\n        emit WhistleblowerReport(_projectId, reportHash);\r\n        _createLog(_projectId, \"CORRUPTION_REPORTED\");\r\n    }\r\n    // //function to view the report description\r\n    // function getWhistleblowerReport(uint256 _projectId, string memory _evidence) public view returns (string memory) {\r\n    //     bytes32 reportHash = keccak256(abi.encodePacked(_projectId, msg.sender, _evidence));\r\n    //     require(whistleblowerReports[reportHash], \"Report does not exist\");\r\n    //     return reportDescriptions[reportHash];\r\n    // }\r\n    // Allow contract owner to blacklist a bidder\r\n    function blacklistBidder(uint256 _bidderId) public onlyOwner {\r\n        bidders[_bidderId].blacklisted = true;\r\n        _createLog(0, \"BIDDER_BLACKLISTED\");\r\n    }\r\n\r\n    // Function to verify if a project is past deadline\r\n    function isProjectLate(uint256 _projectId) public view returns (bool) {\r\n        return block.timestamp > projects[_projectId].deadline;\r\n    }\r\n\r\n    // Rest of existing functions with security and anti-corruption enhancements\r\n\r\n    function createBid(uint256 _projectId, string memory _proposalIPFHash, uint256 _amount) public {\r\n        Project storage pj = projects[_projectId];\r\n        Bidder storage bidder = bidders[bidderIds[msg.sender]];\r\n\r\n        // Add check for existing bid from this address\r\n        require(!hasBidded[msg.sender][_projectId], \"You have already submitted a bid for this project\");\r\n\r\n        require(!bidder.blacklisted, \"Bidder is blacklisted\");\r\n        require(pj.creator != msg.sender, \"Creator cannot participate in bidding process\");\r\n        require(bidderIds[msg.sender] != 0, \"Bidder does not exist\");\r\n        require(pj.posted == true, \"Project does not exist or is not posted\");\r\n        require(projects[_projectId].creator != address(0), \"Project does not exist\");\r\n        require(!isProjectLate(_projectId), \"Project bidding deadline has passed\");\r\n\r\n        bidCount++;\r\n        if (pj.projectType == ProjectClassfication.FixRate) {\r\n            require(_amount == pj.budget, \"Invalid amount entered, In Fix Rate Amount Must be Fix\");\r\n        }\r\n\r\n        bids[bidCount] = Bid({\r\n            bidId: bidCount,\r\n            projectId: _projectId,\r\n            bidder: msg.sender,\r\n            amount: _amount,\r\n            proposalIPFHash: _proposalIPFHash,\r\n            accepted: false\r\n        });\r\n\r\n        // Mark that this address has bidded for this project\r\n        hasBidded[msg.sender][_projectId] = true;\r\n\r\n        projectBids[_projectId].push(bidCount);\r\n        bidder.totalBids++;\r\n\r\n        emit BidSubmitted(bidCount, _projectId, msg.sender, _amount);\r\n        _createLog(_projectId, \"BID_SUBMITTED\");\r\n    }\r\n\r\n    // Existing bidEvaluation function remains mostly unchanged\r\n    function bidEvaluation(uint256 _projectId) public {\r\n        Project storage pj = projects[_projectId];\r\n        require(pj.posted == true, \"Project does not exist or is not posted\");\r\n        require(projects[_projectId].creator != address(0), \"Project does not exist\");\r\n        require(evaluatedbids[_projectId] != true, \"Bid Already Evaluated\");\r\n        uint256[] memory bidIds = projectBids[_projectId];\r\n        require(bidIds.length > 0, \"No bids available for this project\");\r\n        uint256 winnerBidId = 0;\r\n\r\n        if (pj.projectType == ProjectClassfication.FixRate) {\r\n            uint256 random = uint256(keccak256(abi.encodePacked(block.timestamp, block.prevrandao, msg.sender)));\r\n            evaluatedbids[_projectId] = true;\r\n            winnerBidId = bidIds[random % bidIds.length];\r\n            bondWinners[_projectId] = winnerBidId;\r\n            return;\r\n        } else if (pj.projectType == ProjectClassfication.MinRate) {\r\n            uint256 minBidAmount = type(uint256).max;\r\n            uint256[] memory tiedBids = new uint256[](bidIds.length);\r\n            uint256 tiedCount = 0;\r\n\r\n            for (uint256 i = 0; i < bidIds.length; i++) {\r\n                uint256 currentBidId = bidIds[i];\r\n                uint256 currentBidAmount = bids[currentBidId].amount;\r\n\r\n                if (currentBidAmount < minBidAmount) {\r\n                    minBidAmount = currentBidAmount;\r\n                    tiedCount = 1;\r\n                    tiedBids[0] = currentBidId;\r\n                } else if (currentBidAmount == minBidAmount) {\r\n                    tiedBids[tiedCount] = currentBidId;\r\n                    tiedCount++;\r\n                }\r\n            }\r\n\r\n            uint256 randomIndex = uint256(keccak256(abi.encodePacked(block.timestamp, block.prevrandao, msg.sender))) %\r\n                tiedCount;\r\n            evaluatedbids[_projectId] = true;\r\n            winnerBidId = tiedBids[randomIndex];\r\n            bondWinners[_projectId] = winnerBidId;\r\n            return;\r\n        } else if (pj.projectType == ProjectClassfication.MaxRate) {\r\n            uint256 maxBidAmount = 0;\r\n            uint256[] memory tiedBids = new uint256[](bidIds.length);\r\n            uint256 tiedCount = 0;\r\n\r\n            for (uint256 i = 0; i < bidIds.length; i++) {\r\n                uint256 currentBidId = bidIds[i];\r\n                uint256 currentBidAmount = bids[currentBidId].amount;\r\n\r\n                if (currentBidAmount > maxBidAmount) {\r\n                    maxBidAmount = currentBidAmount;\r\n                    tiedCount = 1;\r\n                    tiedBids[0] = currentBidId;\r\n                } else if (currentBidAmount == maxBidAmount) {\r\n                    tiedBids[tiedCount] = currentBidId;\r\n                    tiedCount++;\r\n                }\r\n            }\r\n\r\n            uint256 randomIndex = uint256(keccak256(abi.encodePacked(block.timestamp, block.prevrandao, msg.sender))) %\r\n                tiedCount;\r\n            evaluatedbids[_projectId] = true;\r\n            winnerBidId = tiedBids[randomIndex];\r\n            bondWinners[_projectId] = winnerBidId;\r\n            return;\r\n        } else {\r\n            revert(\"Unsupported project type\");\r\n        }\r\n    }\r\n    function awardBond(uint256 _projectId, uint256 bidWinner) public payable nonReentrant returns (uint256 _bidWiner) {\r\n        bondCount++;\r\n        Bid storage bd = bids[bidWinner];\r\n        Project storage pj = projects[_projectId];\r\n\r\n        require(pj.posted == true, \"Project Not Posted\");\r\n        require(msg.sender == pj.creator, \"Only project creator can award bond\");\r\n        require(msg.value == bd.amount, \"Must send full bid amount\");\r\n        require(!bidders[bidderIds[bd.bidder]].blacklisted, \"Selected bidder is blacklisted\");\r\n\r\n        // Bond storage with mappings\r\n        bondObligor[bondCount] = bd.bidder;\r\n        bondProjectId[bondCount] = _projectId;\r\n        bondStatus[bondCount] = ProjectStatus.Approved;\r\n        bondCompletion[bondCount] = ProjectCompletion.Signed;\r\n        bondAmount[bondCount] = bd.amount;\r\n\r\n        // Calculate and transfer initial 20% payment\r\n        uint256 initialPayment = (bd.amount * 20) / 100;\r\n        payable(bd.bidder).transfer(initialPayment);\r\n\r\n        // Mark bid as accepted\r\n        bd.accepted = true;\r\n\r\n        emit BondAwarded(_projectId, bd.bidder, bd.amount, initialPayment);\r\n        _createLog(_projectId, \"BOND_AWARDED\");\r\n\r\n        pj.posted = false;\r\n        return bidWinner;\r\n    }\r\n\r\n    // Auditor approval for milestone\r\n    function approveCompletion(uint256 _bondId, ProjectCompletion _milestone) public {\r\n        require(bondObligor[_bondId] != address(0), \"Bond does not exist\");\r\n        require(bondStatus[_bondId] == ProjectStatus.Approved, \"Project not in approved state\");\r\n\r\n        Project storage project = projects[bondProjectId[_bondId]];\r\n        require(msg.sender == project.auditor, \"Only assigned auditor can approve\");\r\n        require(_milestone > bondCompletion[_bondId], \"Invalid milestone\");\r\n\r\n        // Mark this milestone as approved\r\n        bondMilestoneApproved[_bondId][_milestone] = true;\r\n\r\n        emit AuditorApproval(_bondId, _milestone);\r\n        _createLog(bondProjectId[_bondId], \"MILESTONE_APPROVED\");\r\n        // return true;\r\n    }\r\n\r\n    // Modified payment release with auditor verification requirement\r\n    function releasePayment(uint256 _bondId, ProjectCompletion _newCompletion) public nonReentrant {\r\n        require(bondObligor[_bondId] != address(0), \"Bond does not exist\");\r\n        require(bondStatus[_bondId] != ProjectStatus.Completed, \"Project already completed\");\r\n        require(bondStatus[_bondId] != ProjectStatus.Disputed, \"Project is disputed\");\r\n\r\n        Project storage project = projects[bondProjectId[_bondId]];\r\n\r\n        // Verify permissions and completion status\r\n        require(msg.sender == project.creator, \"Only project creator can release payment\");\r\n        require(_newCompletion > bondCompletion[_bondId], \"Invalid completion status\");\r\n\r\n        // If there's an auditor, they must have approved this milestone\r\n        if (project.hasAuditor) {\r\n            require(bondMilestoneApproved[_bondId][_newCompletion], \"Milestone not approved by auditor yet\");\r\n        }\r\n\r\n        // Calculate payment due based on milestone difference\r\n        uint256 previousPercentage = getCompletionPercentage(bondCompletion[_bondId]);\r\n        uint256 newPercentage = getCompletionPercentage(_newCompletion);\r\n        uint256 paymentDue = (bondAmount[_bondId] * (newPercentage - previousPercentage)) / 100;\r\n\r\n        // Update completion status first\r\n        bondCompletion[_bondId] = _newCompletion;\r\n\r\n        // Update bond status if project is completed\r\n        if (_newCompletion == ProjectCompletion.Full) {\r\n            bondStatus[_bondId] = ProjectStatus.Completed;\r\n            // Update reputation score for successful completion\r\n            uint256 bidderId = bidderIds[bondObligor[_bondId]];\r\n            bidders[bidderId].reputationScore += 1;\r\n        }\r\n\r\n        // Transfer milestone payment\r\n        payable(bondObligor[_bondId]).transfer(paymentDue);\r\n\r\n        emit PaymentReleased(_bondId, paymentDue, _newCompletion);\r\n        _createLog(bondProjectId[_bondId], \"PAYMENT_RELEASED\");\r\n    }\r\n\r\n    // Enhanced dispute resolution\r\n    function createDispute(uint256 _bondId, string memory _evidence) public {\r\n        require(bondObligor[_bondId] != address(0), \"Bond does not exist\");\r\n        require(bondStatus[_bondId] == ProjectStatus.Approved, \"Invalid bond status\");\r\n\r\n        Project storage project = projects[bondProjectId[_bondId]];\r\n        require(\r\n            msg.sender == project.creator || msg.sender == bondObligor[_bondId],\r\n            \"Only project creator or obligor can create dispute\"\r\n        );\r\n\r\n        disputeCount++;\r\n        disputes[disputeCount] = Dispute({\r\n            disputeId: disputeCount,\r\n            bondId: _bondId,\r\n            creator: msg.sender,\r\n            mediator: address(0),\r\n            evidence: _evidence,\r\n            resolved: false,\r\n            outcome: DisputeOutcome.Pending\r\n        });\r\n\r\n        bondStatus[_bondId] = ProjectStatus.Disputed;\r\n\r\n        _createLog(bondProjectId[_bondId], \"DISPUTE_CREATED\");\r\n    }\r\n\r\n    // Assign mediator to a dispute\r\n    function assignMediator(uint256 _disputeId, address _mediator) public onlyOwner {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        require(!dispute.resolved, \"Dispute already resolved\");\r\n        require(dispute.mediator == address(0), \"Mediator already assigned\");\r\n\r\n        dispute.mediator = _mediator;\r\n        emit MediatorAssigned(_disputeId, _mediator);\r\n        _createLog(bondProjectId[dispute.bondId], \"MEDIATOR_ASSIGNED\");\r\n    }\r\n\r\n    // Resolve dispute\r\n    function resolveDispute(uint256 _disputeId, DisputeOutcome _outcome) public {\r\n        Dispute storage dispute = disputes[_disputeId];\r\n        require(msg.sender == dispute.mediator, \"Only assigned mediator can resolve\");\r\n        require(!dispute.resolved, \"Dispute already resolved\");\r\n\r\n        dispute.resolved = true;\r\n        dispute.outcome = _outcome;\r\n\r\n        // Handle dispute resolution effects\r\n        if (_outcome == DisputeOutcome.RuledForCreator) {\r\n            // Penalize the obligor\r\n            uint256 bidderId = bidderIds[bondObligor[dispute.bondId]];\r\n            if (bidders[bidderId].reputationScore > 0) {\r\n                bidders[bidderId].reputationScore -= 1;\r\n            }\r\n        } else if (_outcome == DisputeOutcome.RuledForObligor) {\r\n            // Allow obligor to continue work\r\n            bondStatus[dispute.bondId] = ProjectStatus.Approved;\r\n        }\r\n\r\n        emit DisputeResolved(_disputeId, _outcome);\r\n        _createLog(bondProjectId[dispute.bondId], \"DISPUTE_RESOLVED\");\r\n    }\r\n    function getAllProjects() public view returns (Project[] memory) {\r\n        Project[] memory allProjects = new Project[](projectId);\r\n        for (uint256 i = 0; i < projectId; i++) {\r\n            allProjects[i] = projects[i + 1]; // projectId starts from 1\r\n        }\r\n        return allProjects;\r\n    }\r\n    function getProjectById(\r\n        uint256 _projectId\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            string memory title,\r\n            uint256 budget,\r\n            string memory description,\r\n            uint256 deadline,\r\n            bool posted,\r\n            uint256 Id,\r\n            ProjectClassfication projectType,\r\n            address creator,\r\n            uint256 timePeriod\r\n        )\r\n    {\r\n        require(_projectId <= projectId, \"Project does not exist\");\r\n        Project memory project = projects[_projectId];\r\n\r\n        return (\r\n            project.title,\r\n            project.budget,\r\n            project.description,\r\n            project.deadline,\r\n            project.posted,\r\n            project.projectId,\r\n            project.projectType,\r\n            project.creator,\r\n            project.timePeriod\r\n        );\r\n    }\r\n    function getAllActiveProjects() public view returns (Project[] memory) {\r\n        uint256 count = 0;\r\n        // Count active projects\r\n        for (uint256 i = 1; i <= projectId; i++) {\r\n            if (projects[i].posted) {\r\n                count++;\r\n            }\r\n        }\r\n        Project[] memory activeProjects = new Project[](count);\r\n        uint256 j = 0;\r\n        // Collect active projects\r\n        for (uint256 i = 1; i <= projectId; i++) {\r\n            if (projects[i].posted) {\r\n                activeProjects[j] = projects[i];\r\n                j++;\r\n            }\r\n        }\r\n        return activeProjects;\r\n    }\r\n    function getBidsByUser(address _bidder) public view returns (Bid[] memory) {\r\n        // First, count the number of bids by this user\r\n        uint256 count = 0;\r\n        for (uint256 i = 1; i <= bidCount; i++) {\r\n            if (bids[i].bidder == _bidder) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Create array of correct size\r\n        Bid[] memory userBids = new Bid[](count);\r\n        uint256 currentIndex = 0;\r\n\r\n        // Collect all bids by the user\r\n        for (uint256 i = 1; i <= bidCount; i++) {\r\n            if (bids[i].bidder == _bidder) {\r\n                userBids[currentIndex] = bids[i];\r\n                currentIndex++;\r\n            }\r\n        }\r\n\r\n        return userBids;\r\n    }\r\n    function getProjectsByCreator(address _creator) public view returns (Project[] memory) {\r\n        // First, count the number of projects by this creator\r\n        uint256 count = 0;\r\n        for (uint256 i = 1; i <= projectId; i++) {\r\n            if (projects[i].creator == _creator) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Create array of correct size and populate it\r\n        Project[] memory creatorProjects = new Project[](count);\r\n        uint256 currentIndex = 0;\r\n\r\n        // Collect all projects by creator\r\n        for (uint256 i = 1; i <= projectId; i++) {\r\n            if (projects[i].creator == _creator) {\r\n                creatorProjects[currentIndex] = projects[i];\r\n                currentIndex++;\r\n            }\r\n        }\r\n\r\n        return creatorProjects;\r\n    }\r\n    // Get Project Bid Winner\r\n    function getProjectBidWinner(uint256 _projectId) public view returns (uint256 _bidWinnerId) {\r\n        // Project storage pj = projects[_projectId];\r\n        require(evaluatedbids[_projectId] == true, \"Bid Not Evaluated\");\r\n        // require(msg.sender == pj.creator, \"You are Not Authothorized\");\r\n        require(_projectId <= projectId, \"Invalid ProjectId\");\r\n        return bondWinners[_projectId];\r\n    }\r\n    // Get transparency logs for a project\r\n    function getProjectLogs(uint256 _projectId) public view returns (LogEntry[] memory) {\r\n        return transparencyLogs[_projectId];\r\n    }\r\n\r\n    function getCompletionPercentage(ProjectCompletion _completion) public pure returns (uint256) {\r\n        // Return percentages based on completion stage\r\n        if (_completion == ProjectCompletion.Signed) return 20; // Initial 20%\r\n        if (_completion == ProjectCompletion.Quarter) return 40; // +20%\r\n        if (_completion == ProjectCompletion.Half) return 60; // +20%\r\n        if (_completion == ProjectCompletion.ThreeQuarters) return 80; // +20%\r\n        if (_completion == ProjectCompletion.Full) return 100; // Final 20%\r\n        return 0;\r\n    }\r\n    // Function to get the current completion level of a bond\r\n    function getCompletionLevel(uint256 _bondId) public view returns (ProjectCompletion) {\r\n        require(bondObligor[_bondId] != address(0), \"Bond does not exist\");\r\n        return bondCompletion[_bondId];\r\n    }\r\n\r\n    // Removed simple dispute function which is now replaced by more comprehensive dispute resolution system\r\n\r\n    // Using OpenZeppelin's ReentrancyGuard instead of custom nonReentrant modifier\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/YourContract.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// Use openzeppelin to inherit battle-tested implementations (ERC20, ERC721, etc)\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * A smart contract that allows changing a state variable of the contract and tracking the changes\n * It also allows the owner to withdraw the Ether in the contract\n * @author BuidlGuidl\n */\ncontract YourContract {\n    // State Variables\n    address public immutable owner;\n    string public greeting = \"Building Unstoppable Apps!!!\";\n    bool public premium = false;\n    uint256 public totalCounter = 0;\n    mapping(address => uint) public userGreetingCounter;\n\n    // Events: a way to emit log statements from smart contract that can be listened to by external parties\n    event GreetingChange(address indexed greetingSetter, string newGreeting, bool premium, uint256 value);\n\n    // Constructor: Called once on contract deployment\n    // Check packages/hardhat/deploy/00_deploy_your_contract.ts\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    // Modifier: used to define a set of rules that must be met before or after a function is executed\n    // Check the withdraw() function\n    modifier isOwner() {\n        // msg.sender: predefined variable that represents address of the account that called the current function\n        require(msg.sender == owner, \"Not the Owner\");\n        _;\n    }\n\n    /**\n     * Function that allows anyone to change the state variable \"greeting\" of the contract and increase the counters\n     *\n     * @param _newGreeting (string memory) - new greeting to save on the contract\n     */\n    function setGreeting(string memory _newGreeting) public payable {\n        // Change state variables\n        greeting = _newGreeting;\n        totalCounter += 1;\n        userGreetingCounter[msg.sender] += 1;\n\n        // msg.value: built-in global variable that represents the amount of ether sent with the transaction\n        if (msg.value > 0) {\n            premium = true;\n        } else {\n            premium = false;\n        }\n\n        // emit: keyword used to trigger an event\n        emit GreetingChange(msg.sender, _newGreeting, msg.value > 0, msg.value);\n    }\n\n    /**\n     * Function that allows the owner to withdraw all the Ether in the contract\n     * The function can only be called by the owner of the contract as defined by the isOwner modifier\n     */\n    function withdraw() public isOwner {\n        (bool success, ) = owner.call{ value: address(this).balance }(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n    /**\n     * Function that allows the contract to receive ETH\n     */\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}